## 11 UDP:用户数据报协议

### 11.1 引言
UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP，应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。

UDP数据报封装成一份IP数据报的格式如图
!(UDP 封装)[./_images/udp-pac.png)

UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。由于缺乏可靠性，我们似乎觉得要避免使用UDP而使用一种可靠协议如TCP。

应用程序必须关心IP数据报的长度。如果它超过网络的MTU（2.8节），那么就要对IP数据报进行分片。如果需要，源端到目的端之间的每个网络都要进行分片，并不只是发送端主机连接第一个网络才这样做

### 11.2 UDP首部

UDP首部的各字段如图
!()[./_images/udp-head.png]

端口号表示发送进程和接收进程。在图1-8中，我们画出了TCP和UDP用目的端口号来分用来自IP层的数据的过程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。TCP端口号与UDP端口号是相互独立的( 可以同时存在相同端口号)。

UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。这个UDP长度是有冗余的。IP数据报长度指的是数据报全长（图3-1），因此UDP数据报长度是全长减去IP首部的长度

### 11.3 UDP检验和
UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部—并不覆盖IP数据报中的任何数据。

UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的。

UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。如果发送端没有打开检验和选项,而接收端计算检验和有差错,那么 UDP 数据将会 被悄悄的丢掉(不保证送达),而不产生任何差错报文。

###  UDP 长度
UDP 可以很长很长,可以有65535字节那么长。但是一般网络在传送的时候,一次一般传送不了那么长的协议(涉及到 MTU 的问 题),就只好对数据 分片,当然,这些是对 UDP 等上级协议透明的,UDP 不需要关心 IP 协议层对数据如何分片,下一个章节将会稍 微讨论一些分片的策略。

### IP 分片
IP在从上层接到数据以后,要根据IP地址来判断从那个接口发送数据(通过选路),并进行MTU的查询,如果数据大小超过MTU 就进行数据分片。数 据的分片是对上层和下层透明,而数据也只是到达目的地还会被重新组装,不过不用担心,IP 层提供了足够的信 息进行数据的再组装。

在 IP 头里面,16bit 识别号唯一记录了一个 IP 包的 ID,具有同一个 ID 的 IP 片将会被重新组装;而13位片偏移则记录了某 IP 片相对整个包的 位置;而这两个表示中间的3bit 标志则标示着该分片后面是否还有新的分片。这三个标示就组成了 IP 分片的所有信息,接 受方就可以利用这些信息对 IP 数据 进行重新组织(就算是后面的分片比前面的分片先到,这些信息也是足够了)。

因为分片技术在网络上被经常的使用,所以伪造 IP 分片包进行流氓攻击的软件和人也就层出不穷。可以用 Trancdroute 程序来进行简单的 MTU 侦测。请参看教材。

### UDP 和 ARP 之间的交互式用
这是不常被人注意到的一个细节,这是针对一些系统地实现来说的。当 ARP 缓存还是空的时候。UDP 在被发送之前一定要发送一个 ARP 请求来获得目的 主机的 MAC 地址,如果这个 UDP 的数据包足够大,大到 IP 层一定要对其进行分片的时候,想象中,该 UDP 数据包的第一个分片会发出一个 ARP 查询请求, 所有的分片都辉等到这个查询完成以后再发送。事实上是这样吗?

结果是,某些系统会让每一个分片都发送一个 ARP 查询,所有的分片都在等待,但是接受到第一个回应的时候,主机却只发送了 最后一个数据片而抛弃了其 他,这实在是让人匪夷所思。这样,因为分片的数据不能被及时组装,接受主机将会在一段时间内将永远 无法组装的 IP 数据包抛弃,并且发送组装超时的 ICMP 报文(其实很多系统不产生这个差错),以保证接受主机自己的接收端缓存不 被那些永远得不到组装的分片满。

### ICMP 源站抑制差错
当目标主机的处理速度赶不上数据接收的速度,因为接受主机的 IP 层缓存会被占满,所以主机就会发出一个“我受不了”的一个 ICMP 报文。
UDP

### UDP 服务器设计
UDP 协议的某些特性将会影响我们的服务器程序设计,大致总结如下:
---
 - 关于客户IP和地址:服务器必须有根据客户IP地址和端口号判断数据包是否合法的能力(这似乎要求每一个服务器都要具备)
 - 关于目的地址:服务器必须要有过滤广播地址的能力。
 - 关于数据输入:通常服务器系统的每一个端口号都会和一块输入缓冲区对应,进来的输入根据先来后到的原则等待服务器的处理,所以难免会出现缓冲区溢出的问题,这种情况下,UDP 数据包可能会被丢弃,而应用服务器程序本身并不知道这个问题。
 - 服务器应该限制本地IP地址,就是说它应该可以把自己绑定到某一个网络接口的某一个端口上。


## 广播和多播

### 12.1 引言
广播和多播仅应用于UDP，它们对需将报文同时传往多个接收者的应用来说十分重要。TCP是一个面向连接的协议，它意味着分别运行于两主机（由IP地址确定）内的两进程（由端口号确定）间存在一条连接。

考虑包含多个主机的共享信道网络如以太网。每个以太网帧包含源主机和目的主机的以太网地址（48bit）。通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播(unicast)。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。

然而，有时一个主机要向网上的所有其他主机发送帧，这就是广播。通过ARP和RARP可以看到这一过程。多播(multicast)处于单播和广播之间：帧仅传送给属于多播组的多个主机。

 广播的设计决定了其它的不应该接收数据报的主机也会接收到数据从而生成负担。但是否真正需要以旧换新处理该数据包，会经过网卡(帧检验和错)，驱动( 协议，mac 地址等)，IP 层(源地址和目的地址等)，UDP(端口号，有时还有源端口号,端口不可达产生icmp报文,检验和错)的过虑(),不符合预期的将会被丢弃。

### 单播(unicast)
单播是说,对特定的主机进行数据传送。例如给某一个主机发送 IP 数据包。这时候,数据链路层给出的数据头里面是非常具体的 目的地址,对于以太网来 说,就是网卡的 MAC 地址(不是 FF-FF-FF-FF-FF-FF 这样的地址)。现在的具有路由功能的主机应该可以将 单播数据定向转发,而目的主机的网 络接口则可以过滤掉和自己 MAC 地址不一致的数据。

### 广播 broadcast

广播是主机针对某一个网络上的所有主机发送数据包。这个网络可能是网络,可能是子网,还可能是所有的子网。如果是网络, 例如 A 类网址的广播就是 netid.255.255.255,如果是子网,则是 netid.netid.subnetid.255;如果是所有的子网(B 类 IP)则是则是 netid.netid.255.255。广播所用的 MAC 地址 FF-FF-FF-FF-FF-FF。网络内所有的主机都会收到这个广播数据,网卡只要把 MAC 地址为 FF-FF-FF-FF-FF-FF 的数据交给内核就可以了。一般说来 ARP,或者路由协议 RIP 应该是以广播的形式播发的。

例如 `ping -b 255.255.255.255` 就可以产生一个广播

### 多播 multicast

可以说广播是多播的特例,多播就是给一组特定的主机(多播组)发送数据,这样,数据的播发范围会小一些(实际上播发的范围 一点也没有变小),多播的 MAC 地址是最高字节的低位为一,例 如01-00-00-00-00-00。多播组的地址是 D 类 IP,规定是 224.0.0.0-239.255.255.255。

虽然多播比较特殊,但是究其原理,多播的数据还是要通过数据链路层进行 MAC 地址绑定然后进行发送。所以一个以太网卡在 绑定了一个多播 IP 地址之 后,必 定还要绑定一个多播的 MAC 地址,才能使得其可以像单播那样工作。这个多播的 IP 和多播 MAC 地址有一个对应的算法,在书的 p133到 p134之间。可以 看到 这个对应不是一一对应的,主机还是要对多播数据进行过滤。

## 13 IGMP:Internet组管理协议

### 13.1 引言
多播的Internet组管理协议（IGMP）。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。IGMP在RFC 111 2中定义[Deering 1989]。

一般多播路由器根本不需要知道 某一个多播组里面有多少个 主机,而只要知道自己的子网内还有没有处于某个多播组的主机就可以了。只要某一个多播组还有一台主 机,多播路由器就会把数据传输出去,这样,接受方就会通 过网卡过滤功能来得到自己想要的数据。为了知道多播组的信息,多播路 由器需要定时的发送 IGMP 查询,IGMP 的格式可以看书,各个多播组里面的主机要根 据查询来回复自己的状态。路由器来决定有几 个多播组,自己要对某一个多播组发送什么样的数据。

这种查询回应数据报的 TTL 一般是1,而且就算是出错也不产生 ICMP 差错(没必要)。

## 14 DNS:域名系统

### 14.1 引言
域名系统（DNS）是一种用于TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。这里提到的分布式是指在Internet上的单个站点不能拥有所有的信息。

从应用的角度上看，对DNS的访问是通过一个地址解析器（resolver）来完成的。在Unix主机中，该解析器主要是通过两个库函数gethostbyname(3)和gethostbyaddr(3)来访问的，它们在编译应用程序时与应用程序连接在一起。前者接收主机名字返回IP地址，而后者接收IP地址来寻找主机名字。解析器通过一个或多个名字服务器来完成这种相互转换。

### DNS 系统介绍

DNS 的全称是 Domain Name System。它负责把 FQDN(就是以"."分隔结尾的名字)翻译成一个 IP。最初的 DNS 系统使用的是一个 巨大的 hosts.txt 文件(很吃惊,用 这个就好使了?),可是一段时间以后,开发这就不得不用数据库来代替 hosts.txt 文件,最终发展到 了现在的分布式数据库。

从书中的143页可以看到,DNS 系统是一个巨大的树,最上方有一个无名树根,下一层是 arpa,com,edu,gov,int,mil,us, cn。等等, 其中 arpa,是域名反解析树的顶端;而 com,edu,等域名本来只用在美国(这就是技术特权啊),但是现在几乎全世界通用;而 us, cn, 等叫做国家域。这个树里面的域名并不是统一管理的,网络信息中心(NIS)负责分配顶级域合委派其他制定地区域的授权机构。

一个独立管理的 DNS 子树叫做 zone,最常见的区域就是二级域名,比如说.com.cn。我们还可以把这个二级域名给划分成更小的 区域,比如说 sina.com.cn。

DNS 系统是一个分布式的数据库,当一个数据库发现自己并没有某查询所需要的数据的时候,它将把查询转发出去,而转发的目 的地通常是根服务器,根服 务器从上至下层层转发查询,直到找到目标为止。DNS 还有一个特点就是使用高速缓存,DNS 把查询过 的数据缓存在某处,以便于下次查询时使用。


### DNS 协议

对应原书章节

《TCP/IP详解 卷1：协议》在线阅读版 - 第14章 DNS：域名系统
前言

前面已经提到了访问一台机器要靠 IP 地址和 MAC 地址,其中,MAC 地址可以通过 ARP 协议得到,所以这对用户是透明的,但是 IP 地址就不行,无论如何用户都需要用一个指定的 IP 来访问一台计算机,而 IP 地址又非常不好记,于是就出现了 DNS 系统
DNS 系统介绍

DNS 的全称是 Domain Name System。它负责把 FQDN(就是以"."分隔结尾的名字)翻译成一个 IP。最初的 DNS 系统使用的是一个 巨大的 hosts.txt 文件(很吃惊,用 这个就好使了?),可是一段时间以后,开发这就不得不用数据库来代替 hosts.txt 文件,最终发展到 了现在的分布式数据库。

从书中的143页可以看到,DNS 系统是一个巨大的树,最上方有一个无名树根,下一层是 arpa,com,edu,gov,int,mil,us, cn。等等, 其中 arpa,是域名反解析树的顶端;而 com,edu,等域名本来只用在美国(这就是技术特权啊),但是现在几乎全世界通用;而 us, cn, 等叫做国家域。这个树里面的域名并不是统一管理的,网络信息中心(NIS)负责分配顶级域合委派其他制定地区域的授权机构。

一个独立管理的 DNS 子树叫做 zone,最常见的区域就是二级域名,比如说.com.cn。我们还可以把这个二级域名给划分成更小的 区域,比如说 sina.com.cn。

DNS 系统是一个分布式的数据库,当一个数据库发现自己并没有某查询所需要的数据的时候,它将把查询转发出去,而转发的目 的地通常是根服务器,根服 务器从上至下层层转发查询,直到找到目标为止。DNS 还有一个特点就是使用高速缓存,DNS 把查询过 的数据缓存在某处,以便于下次查询时使用。

### DNS 协议

DNS 报文定义了一个既可以查询也可以响应的报文格式。具体格式可以看《TCP/IP详解 卷1：协议》P145页。对各个字段简单解释如下：
!()[./images/dns-pac.png]
 - 最前面的16个 bit 唯一的标示了问题号码,用于查询端区别自己的查询。
 - 紧接着的16个 bit 又可以做进一步的细分,标示了报文的性质和一些细节,比如说是查询报文还是响应报文,需要递归 查询与否(一般服务器都支持递归查询,而且不需要任何设置,BIND 就是这样)
 - 查询问题后面有查询类型,包括 A,NS,CNAME,PTR,HINFO,MX,如果熟悉 BIND 的话,就知道在 zong 的配置 文件里面,每一条记录都记载了各自的类型,比如 A 就是 IP 地址,NS 就是名字服务器。
 - 响应报文可以回复多个 IP,也就是说,域名可以和多个 IP 地址对应,并且有很多 CNAME。



### 反向查询
正向查询指的是通过域名得到 IP 的查询,而反向查询就是通过 IP 得到域名。例如用 host 命令,host ip 就可以得到服务器的域名, host domainName 就得到 IP。

稍微知道一点数据结构的人都能意识到,在正向查询的域里面做反向查询,其做法只有遍历整个数据集合----对于 DNS 来说,那 就是遍历整个数据库, 这将带来巨大的负担,所以 DNS 采取了另一种方法,使用另一棵子树来维护 IP-〉域名的对应表。这个子树的根节点是 in-addr.arpa,而一个 IP 例如192.168.11.2)所具有的 DNS 地址就是 2.11.168.192.in-addr.arpa(ip 倒置)。在 DNS 系统里面,一个 反向地址对应一个 PTR 纪录(对应 A 纪录),所以反向查询又叫 做指针(PTR)查询。


### 其他问题的讨论

#### DNS 服务器高速缓存

BIND9默认是作为一个高速缓存服务器,其将所有的查询都转交到根服务器去,然后得到结果并放在本地的缓冲区,以加快查询
速度。如果有兴趣可以安装一个 BIND9来尝试一下。而自己定义的 zone 则可以规定其在缓存中的时间,一般是1天(就是配置文件中 的1D)。

#### 用 UDP 还是 TCP

DNS 服务器支持 TCP 和 UDP 两种协议的查询方式,而且端口都是53。而大多数的查询都是 UDP 查询的,一般需要 TCP 查询的 有两种情况:

当查询数据多大以至于产生了数据截断(TC标志为1),这时,需要利用TCP的分片能力来进行数据传输(看TCP的相关章节)。
当主(master)服务器和辅(slave)服务器之间通信,辅服务器要拿到主服务器的 zone 信息的时候。

## TFTP:简单文件传送协议

## BOOTP:引导程序协议


